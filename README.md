# Jump Point Search

Данный репозиторий содержит файлы по проекту, цели которого написать алгоритм Jump Point Searh (JPS) и улучшения к нему, а также сравнить их
с обычным алгоритмом A*. Реализация в этом проекте работает на 8-ми связном клетчатом поле (допустимо 8 ходов: влево, вправо, вниз, вверх и по диагоналям), а
также допускает срезание углов (то есть проход по дигонали через угол препятствия допускается).

*Комментарий:* Сам алгоритм JPS работает всегда ТОЛЬКО на 8-ми связном поле - для других враиантов то, на чём основан этот алгоритм, будет неверно.

Данные для тестирования взяты отсюда: https://movingai.com/benchmarks/grids.html.

Базовая реализация алгоритма JPS основана на данной статье: http://grastien.net/ban/articles/hg-aaai11.pdf.

Также в данном проекте реализовано улучшение `Block-based Symmetry Breaking`, основная идея которого заключается в том, чтобы просматривать горизонатали и вертикали не 
по одному шагу, а сразу блоками из битов, что позволяет существенно повысить скорость работы (подробнее об этом улучшении - в статье
https://harabor.net/data/papers/harabor-grastien-icaps14.pdf).

### Инструкция по запуску проекта:
Весь код проекта находится в одной Jupyter-тетрадке по названием `JPS_benchmarking.ipynb`, там же находится и benchmarking (то есть сравнение результатов работы
алгоритмов друг с другом). Чтобы запустить всю эту тетрадку и повторить резульаты исследования, вам понадобится скачать саму эту тетрадку, а также три директории с картами, 
на которых проводилось тестирование (директории: `IceFloes из Starcraft`, `lac304d из Dragon Age Origins` и `Москва`). Директории и тетрадка должны находиться на одном уровне
вложенности в вашей файловой системе (например, можно в одну папочку всё это сложить). Ознакомиться с результатами исследования (подробными графиками) можно в папке `результаты`.


### Если есть желание отдельно протестировать класс Map():

Вы можете задать вручную карту (как образец класса Map()) таким образом:
```
height = 15
width = 30
map_str = '''
. . . . . . . . . . . . . . . . . . . . . # # . . . . . . .  
. . . . . . . . . . . . . . . . . . . . . # # . . . . . . . 
. . . . . . . . . . . . . . . . . . . . . # # . . . . . . . 
. . . # # . . . . . . . . . . . . . . . . # # . . . . . . . 
. . . # # . . . . . . . . # # . . . . . . # # . . . . . . . 
. . . # # . . . . . . . . # # . . . . . . # # # # # . . . . 
. . . # # . . . . . . . . # # . . . . . . # # # # # . . . . 
. . . # # . . . . . . . . # # . . . . . . . . . . . . . . . 
. . . # # . . . . . . . . # # . . . . . . . . . . . . . . . 
. . . # # . . . . . . . . # # . . . . . . . . . . . . . . . 
. . . # # . . . . . . . . # # . . . . . . . . . . . . . . . 
. . . # # . . . . . . . . # # . . . . . . . . . . . . . . . 
. . . . . . . . . . . . . # # . . . . . . . . . . . . . . . 
. . . . . . . . . . . . . # # . . . . . . . . . . . . . . .
. . . . . . . . . . . . . # # . . . . . . . . . . . . . . .
'''
start = Node(9, 0)
goal = Node(13, 28)

test_map = Map()
test_map.read_from_string(map_str, width, height)
draw(test_map, start, goal)
```
В этом примере сначала вводится размер карты, затем описание каждой её клетки (`.` - свободное поле, `#` - препятствие), затем создаются два представителя
класса Node() - вершина start (из которой начинаем маршрут) и вершина goal (целевая вершина). Далее едёт создание представителя класса Map(), куда затем загружается
написанная нами карта. В конце используется функция draw(), чтобы визуализировать карту.

Также карту можно считать из файла, как это делается в данном проекте для тестирования (тут считываются три карты, на котрых мы тестируем JPS).

После того, как у вас появилась карта `test_map`, вы можете протестировать отдельные функции класса на ней, например:
```
P = (4, 12)
N = (5, 11)
test_map.BLOCK_identify_successors(N, P, (start.i, start.j), (goal.i, goal.j))
test_map.block_jump(N=N, start=(start.i, start.j), goal=(goal.i, goal.j), P=(5, 11))
# и так далее
```
Тут мы сначала ввели две точки: N и P (считаем, что в N пришли из P), а затем использовали ращличные функции класса Map() на нашей карте.

### Если вы желаете воспользоваться написанными в проекте алгоритмами A*, JPS или его модификацией с блоками:

Путь у вас есть карта test_map (как в предыдущем пункте, например), координаты начальной вершины: (start_i, start_j), координаты целевой вершины: 
(goal_i, goal_j), а также есть эвристическая функция octile_distance и класс дерева поиска SearchTreePQS (см. код проекта), тогда, чтобы
запустить JPS на этой карте, вызовите функцию:
```
find_path, last_node, num_steps, nodes_created, open, closed = JPS(grid_map=test_map, 
                                                                   start_i=start_i, start_j=start_j,
                                                                   goal_i=goal_i, goal_j=goal_j, 
                                                                   heuristic_func=octile_distance, 
                                                                   search_tree=SearchTreePQS,
                                                                   BLOCK_param=w) 
```
где в качестве `w` можно передать `None`, если вы хотите обычный JPS или число, если вы хотите JPS с блоком размера = это число.

Чтобы запустить A*, вызовите аналогичную функцию:
```
find_path, last_node, num_steps, nodes_created, open, closed = astar(test_map, start_i, start_j, goal_i, 
                                                                     goal_j, heuristic_func=octile_distance, 
                                                                     search_tree=SearchTreePQS)
```
Все варианты алгоритмов возвращают 6 параметров:
```
find_path - это булева переменная: True, если путь от стартовой вершины найден; False, если не найден (то есть такого пути попросту нет - например, если препятствия полностью окружают целевую вершину)


last_node - это объект класса Node(), это последняя вершина на пути, который строит алгоритм (если путь найден, то эта вершина совпадает с goal); у неё можно взять g-значение (last_node.g) - это будет длина найденного наикратчайшего пути до этой вершины

num_steps - число шагов, сделанных алгоритмов

nodes_created - число созданных вершин (объектов класса Node())

open и closed - два списка вершин - список OPEN и CLOSED (см как работает A*)
```

### Заключение
Мы проверяли алгорим A*, JPS и его модернизацию с блоками на более, чем 300 тестах и всё работало! Так что надеемся, что все алгоритмы корректны.
